 c.say(taskToIcon(c.memory.task), true)

 // Utility functions
const taskToIcon = (t: CreepTask) => {
  switch(t){
    case T_WITHDRAW: return 'ğŸ’°'
    case T_MINE: return 'â›ï¸'
    case T_IDLE: return 'ğŸ’¤'
    case T_REPAIR: return 'ğŸ› ï¸'
    case T_TRANSFER: return 'ğŸ“¦'
    case T_UPGRADE: return 'ğŸ‘'
    case T_ATTACK: return 'âš”ï¸'
    case T_RESERVE: return 'ğŸš€'
    case T_CLAIM: return 'â›³'
    case T_RECYCLE: return 'â™»ï¸'
    default: return t
  }
}

// Slack TEST
    if ((Game.time % 100 === 0 && Config.ENABLE_SLACK) ) {
      let fieldHarvesters: Slack.FieldsEntity = new Slack.FieldsEntity("Harvesters", harvestersSize.toString(), true);
      let fieldUpgraders: Slack.FieldsEntity = new Slack.FieldsEntity("Upgraders", upgradersSize.toString(), true);
      let fieldSpawnValue = (room.energyAvailable + " / " + room.energyCapacityAvailable).toString();
      let fieldSpawn: Slack.FieldsEntity = new Slack.FieldsEntity("Spawn Energy", fieldSpawnValue);
      basicAttach.text = "CPU: limit: " + Game.cpu.limit + ", tickLimit: " + Game.cpu.tickLimit +
      ", bucket: " + Game.cpu.bucket + ", used: " + Game.cpu.getUsed();
      basicAttach.fields = [fieldHarvesters, fieldUpgraders, fieldSpawn];

      let Testload: Slack.Payload = new Slack.Payload(SlackConfig.SLACK_USERNAME, [basicAttach]);

      Slack.postToSlack(Testload);
    }
